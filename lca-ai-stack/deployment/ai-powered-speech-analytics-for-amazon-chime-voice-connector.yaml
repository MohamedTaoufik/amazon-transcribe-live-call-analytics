# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31

Description: Amazon Transcribe Live Call Analytics - LCA AI Stack

Parameters:
  S3BucketName:
    Type: String
    Description: >
      (Optional) Existing bucket where call recording files will be stored.
      Leave blank to automatically create new bucket.
    # yamllint disable rule:line-length
    AllowedPattern: '( *|(?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$))'
    # yamllint enable rule:line-length

  AudioFilePrefix:
    Type: String
    Default: lca-audio-recordings/
    Description: >-
      The Amazon S3 prefix where the merged output audio files will be saved (must end in "/")

  MonoAudioFilePrefix:
    Type: String
    Default: lca-mono-audio-recordings/
    Description: >-
      The Amazon S3 prefix where the mono output audio files will be saved (must end in "/")

  DynamoDbExpirationInDays:
    Type: Number
    Default: 90
    Description: >-
      Number of days set in the time to live of event data stored in the DynamoDB table

  IsContentRedactionEnabled:
    Type: String
    Default: "false"
    Description: >-
      Enable content redaction from Amazon Transcribe transcription output. This is only used when
      the 'en-US' language is selected in the TranscribeLanguageCode parameter.
    AllowedValues:
      - "true"
      - "false"

  TranscribeContentRedactionType:
    Type: String
    Default: PII
    Description: >-
      Type of content redaction from Amazon Transcribe transcription output
    AllowedValues:
      - PII

  TranscribeLanguageCode:
    Type: String
    Description: >-
      Language code to be used for Amazon Transcribe
    Default: en-US
    AllowedValues:
      - en-US
      - es-US
      # - en-GB
      # - fr-CA
      # - fr-FR
      # - en-AU
      # - it-IT
      # - de-DE
      # - pt-BR
      # - ja-JP
      # - ko-KR
      # - zh-CN

  TranscribePiiEntityTypes:
    Type: String
    # yamllint disable rule:line-length
    Default: BANK_ACCOUNT_NUMBER,BANK_ROUTING,CREDIT_DEBIT_NUMBER,CREDIT_DEBIT_CVV,CREDIT_DEBIT_EXPIRY,PIN,EMAIL,ADDRESS,NAME,PHONE,SSN
    # yamllint enable rule:line-length
    Description: >-
      Select the PII entity types you want to identify or redact. Remove the values that you don't
      want to redact from the default.  DO NOT ADD CUSTOM VALUES HERE.

  CustomVocabularyName:
    Type: String
    Default: ''
    Description: >-
      The name of the vocabulary to use when processing the transcription job. Leave blank if no
      custom vocabulary to be used. If yes, the custom vocabulary must pre-exist in your account.

  IsSentimentAnalysisEnabled:
    Type: String
    Default: 'true'
    Description: >-
      Enable sentiment analysis using Amazon Comprehend
    AllowedValues:
      - 'true'
      - 'false'

  ComprehendLanguageCode:
    Type: String
    Description: >-
      Language code to be used for Amazon Comprehend to detect sentiment. This
      should match the Amazon Transcribe language.
    Default: en
    AllowedValues:
      - en
      - es
      # - fr
      # - de
      # - it
      # - pt
      # - ar
      # - hi
      # - ja
      # - ko
      # - zh
      # - zh-TW

  CloudFrontPriceClass:
    Type: String
    Default: PriceClass_100
    Description: >-
      Specify the CloudFront price class. See https://aws.amazon.com/cloudfront/pricing/ for a
      description of each price class.
    AllowedValues:
      - PriceClass_100
      - PriceClass_200
      - PriceClass_All
    ConstraintDescription: >-
      Allowed Price Classes PriceClass_100 PriceClass_200 and PriceClass_All

  CloudFrontAllowedGeos:
    Type: String
    Default: ''
    Description: >-
      Specify a comma separated list of two letter country codes (uppercase ISO 3166-1) that are
      allowed to access the web user interface via CloudFront. For example: US,CA. Leave empty if
      you do not want geo restrictions to be applied.
    AllowedPattern: '^(|[A-Z]{2}(,[A-Z]{2})*)$'
    ConstraintDescription: >-
      Comma separated list of uppercase two letter country codes or empty

  AdminEmail:
    Type: String
    Description: >-
      Email address of admin user (e.g. jdoe@example.com) used for the API and web UI.
      An initial temporary password will be automatically sent to this user via email.
    AllowedPattern: '^[\w.+-]+@([\w-]+\.)+[\w-]{2,6}$'

  AllowedSignUpEmailDomain:
    Type: String
    Default: ''
    Description: >-
      Email address domain (e.g. example.com) that is allowed to signin and signup using the web UI.
      If left empty, signup via the web UI is disabled and users will have to be created using
      Cognito.
    AllowedPattern: '^(|([\w-]+\.)+[\w-]{2,6})$'

Metadata:
  "AWS::CloudFormation::Interface":
    ParameterGroups:
      - Label:
          default: Amazon S3 Configuration
        Parameters:
          - S3BucketName
          - AudioFilePrefix
          - MonoAudioFilePrefix
      - Label:
          default: Amazon CloudFront Configuration
        Parameters:
          - CloudFrontPriceClass
          - CloudFrontAllowedGeos
    ParameterLabels:
      S3BucketName:
        default: Call Audio Bucket Name
      CloudFrontPriceClass:
        default: CloudFront Price Class
      CloudFrontAllowedGeos:
        default: CloudFront Allowed Geographies
      AudioFilePrefix:
        default: Audio File Prefix
      IsContentRedactionEnabled:
        default: Enable Content Redaction
      TranscribeContentRedactionType:
        default: Type of Content Redaction
      TranscribeLanguageCode:
        default: Transcription Language Code
      TranscribePiiEntityTypes:
        default: Transcription PII Redaction Entity Types
      CustomVocabularyName:
        default: Transcription Custom Vocabulary Name
      IsSentimentAnalysisEnabled:
        default: Enable Sentiment Analysis with Comprehend
      ComprehendLanguageCode:
        default: Comprehend Sentiment Analysis Language Code

Conditions:
  ShouldCreateRecordingBucket: !Equals [!Ref S3BucketName, ""]
  ShouldAllowSignUpEmailDomain: !Not [!Equals [!Ref AllowedSignUpEmailDomain, ""]]
  ShouldEnableContentRedaction: !And
    - !Equals [!Ref IsContentRedactionEnabled, 'true']
    - !Equals [!Ref TranscribeLanguageCode, 'en-US']
  ShouldEnableGeoRestriction: !Not [!Equals [!Ref CloudFrontAllowedGeos, '']]

Outputs:
  EventSourcingTableArn:
    Description: >-
      The ARN of the DynamoDB table created to store events and the contact
      details used in this solution
    Value: !GetAtt EventSourcingTable.Arn
  S3BucketName:
    Description: Bucket which contains all the call recordings
    Value: !If
      - ShouldCreateRecordingBucket
      - !Ref RecordingsBucket
      - !Ref S3BucketName
  CloudfrontEndpoint:
    Description: Endpoint for Cloudfront distribution
    Value: !Sub "https://${WebAppCloudFrontDistribution.DomainName}/"

Resources:
  
  ## BUCKET TO STORE STEREO RECORDINGS
  RecordingsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Condition: ShouldCreateRecordingBucket
    Properties:
      AccessControl: LogDeliveryWrite
      # XXX figure out access logging
      # LoggingConfiguration:
      #    DestinationBucketName: !Ref S3BucketName
      #    LogFilePrefix: 'logs/'
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: True
        BlockPublicPolicy: True
        IgnorePublicAcls: True
        RestrictPublicBuckets: True
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  RecordingsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Condition: ShouldCreateRecordingBucket
    Properties:
      Bucket: !Ref RecordingsBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - "s3:*"
            Effect: "Deny"
            Principal: "*"
            Resource:
              - !GetAtt RecordingsBucket.Arn
              - !Sub "${RecordingsBucket.Arn}/*"
            Condition:
              Bool:
                "aws:SecureTransport": false

  EventSourcingTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AttributeDefinitions:
        # primary key attributes
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      TimeToLiveSpecification:
        AttributeName: ExpiresAfter
        Enabled: true
      StreamSpecification:
        StreamViewType: NEW_IMAGE

  # Add permissions to the default key to allow S3 access
  SQSManagedKey:
    Type: AWS::KMS::Key
    Properties:
      EnableKeyRotation: true
      KeyPolicy:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - "s3.amazonaws.com"
            Action:
              - "kms:GenerateDataKey*"
              - "kms:Decrypt"
            Resource: "*"
          - Effect: Allow
            Principal:
              AWS: !Join
                - ''
                - - 'arn:aws:iam::'
                  - !Ref 'AWS::AccountId'
                  - ':root'
            Action:
              - "kms:*"
            Resource: "*"

  ##########################################################################
  # Call Transcriber
  ##########################################################################

  CallTranscriberFunction:
    Type: AWS::Serverless::Function
    Properties:
      Description: >-
        AWS Lambda Function that will be triggered when a new call starts. This will
        read from the KVS streams, stitch the channels together, send audio to
        transcribe, and store the transcriptions in DynamoDB
      Handler: index.handler
      Role: !GetAtt CallTranscriberFunctionRole.Arn
      Runtime: nodejs14.x
      MemorySize: 2048
      Timeout: 900
      Environment:
        Variables:
          LAMBDA_INVOKE_TIMEOUT: "720000"
          EVENT_SOURCING_TABLE_NAME: !Ref EventSourcingTable
          EXPIRATION_IN_DAYS: !Ref DynamoDbExpirationInDays
          REGION: !Ref AWS::Region
          OUTPUT_BUCKET: !If
            - ShouldCreateRecordingBucket
            - !Ref RecordingsBucket
            - !Ref S3BucketName
          RECORDING_FILE_PREFIX: !Ref AudioFilePrefix
          MONO_RECORDING_FILE_PREFIX: !Ref MonoAudioFilePrefix
          RAW_FILE_PREFIX: 'lca-audio-raw/'
          TEMP_FILE_PATH: '/tmp/'
          SAVE_PARTIAL_TRANSCRIPTS: 'true'
          IS_CONTENT_REDACTION_ENABLED: !If
            - ShouldEnableContentRedaction
            - 'true'
            - 'false'
          TRANSCRIBE_LANGUAGE_CODE: !Ref TranscribeLanguageCode
          CONTENT_REDACTION_TYPE: !Ref TranscribeContentRedactionType
          PII_ENTITY_TYPES: !Ref TranscribePiiEntityTypes
          CUSTOM_VOCABULARY_NAME: !Ref CustomVocabularyName
      CodeUri: ../source/lambda_functions/call_transcriber
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired

  CallTranscriberFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: lambda-policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                - transcribe:DeleteTranscriptionJob
                - transcribe:GetTranscriptionJob
                - transcribe:GetVocabulary
                - transcribe:ListTranscriptionJobs
                - transcribe:ListVocabularies
                - transcribe:StartStreamTranscription
                - transcribe:StartTranscriptionJob
                Resource: "*"
              - Effect: Allow
                Action:
                - lambda:InvokeFunction
                Resource: 
                  - !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*-CallTranscriberFunction-*"
              - Action:
                  - "kinesisvideo:Describe*"
                  - "kinesisvideo:Get*"
                  - "kinesisvideo:List*"
                Effect: "Allow"
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:\
                    ${AWS::AccountId}:log-group:/aws/lambda/*"
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt EventSourcingTable.Arn
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - !Sub
                    - "arn:aws:s3:::${bucket}"
                    - bucket: !If
                        - ShouldCreateRecordingBucket
                        - !Ref RecordingsBucket
                        - !Ref S3BucketName
                  - !Sub
                    - "arn:aws:s3:::${bucket}/*"
                    - bucket: !If
                        - ShouldCreateRecordingBucket
                        - !Ref RecordingsBucket
                        - !Ref S3BucketName

  AllowEventBridgeToCallTranscriberFunctionLambda:
    Type: "AWS::Lambda::Permission"
    Properties:
      FunctionName: !Ref CallTranscriberFunction
      Action: "lambda:InvokeFunction"
      Principal: events.amazonaws.com
      SourceArn: !GetAtt EventBridgeRuleToTriggerCallTranscriberLambda.Arn
      SourceAccount: !Ref AWS::AccountId

  EventBridgeRuleToTriggerCallTranscriberLambda:
    Type: AWS::Events::Rule
    Properties:
      Description: "This rule is triggered when the Chime VoiceConnector streaming status changes"
      EventPattern:
        detail-type:
          - "Chime VoiceConnector Streaming Status"
        source:
          - aws.chime
      Targets:
        - Id: CallTranscriberTarget
          Arn: !GetAtt CallTranscriberFunction.Arn
      State: "ENABLED"
  
  ##########################################################################
  # Event Sourcing Processor
  ##########################################################################

  CallEventStreamProcessFunction:
    Type: AWS::Serverless::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
    Properties:
      CodeUri: ../source/lambda_functions/call_event_stream_processor
      Description: >-
        Call Event DynamoDB Table Stream Processor
      Events:
        # https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-function-dynamodb.html
        DynamoDBStream:
          Type: DynamoDB
          Properties:
            BisectBatchOnFunctionError: true
            # TODO Add SQS queue for discarded records
            # DestinationConfig:
            Enabled: true
            MaximumRetryAttempts: 3
            Stream: !GetAtt EventSourcingTable.StreamArn
            StartingPosition: LATEST
            BatchSize: 20
            # Tumbling Window is used for aggregations over different invocations
            # https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-windows
            TumblingWindowInSeconds: 900
      AutoPublishAlias: live
      DeploymentPreference:
        # TODO change to gradual deployments
        Type: AllAtOnce
        # TODO add alarms to detect application level errors for automatic rollback
      Handler: lambda_function.handler
      Layers:
        - !Ref CallEventStreamProcessLayer
        # periodically update the Lambda Insights Layer
        # https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-extension-versions.html
        - !Sub "arn:aws:lambda:${AWS::Region}:580247275435:layer:LambdaInsightsExtension:16"
      MemorySize: 2048
      # policy templates:
      # https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-policy-templates.html
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref EventSourcingTable
        - DynamoDBStreamReadPolicy:
            TableName: !Ref EventSourcingTable
            StreamName: !Select
              - 3
              - !Split
                - /
                - !GetAtt EventSourcingTable.StreamArn
        - Statement:
            - Effect: Allow
              Action:
                - appsync:GraphQL
              Resource:
                - !Sub "${AppSyncApi.Arn}/types/Mutation/*"
                - !Sub "${AppSyncApi.Arn}/types/Query/fields/__schema"
            - Effect: Allow
              Action:
                - comprehend:DetectSentiment
              Resource: "*"
        # CloudWatch Insights Managed Policy
        - arn:aws:iam::aws:policy/CloudWatchLambdaInsightsExecutionRolePolicy
      Runtime: python3.9
      Timeout: 60
      Tracing: Active
      Environment:
        Variables:
          # XXX add log level parameter or map
          LOG_LEVEL: DEBUG
          POWERTOOLS_METRICS_NAMESPACE: !Sub "CallAnalytics-${AWS::StackName}"
          POWERTOOLS_SERVICE_NAME: CallEventStreamProcessor
          # XXX add trace parameter or map
          POWERTOOLS_TRACE_DISABLED: false
          EVENT_SOURCING_TABLE_NAME: !Ref EventSourcingTable
          APPSYNC_GRAPHQL_URL: !GetAtt AppSyncApi.GraphQLUrl
          COMPREHEND_LANGUAGE_CODE: !Ref ComprehendLanguageCode
          IS_SENTIMENT_ANALYSIS_ENABLED: !Ref IsSentimentAnalysisEnabled

  CallEventStreamProcessLayer:
    Type: AWS::Serverless::LayerVersion
    Metadata:
      BuildMethod: python3.9
    Properties:
      Description: >-
        Call Event DynamoDB Table Stream Processor Layer
      ContentUri: ../source/lambda_layers/call_event_stream_processor
      CompatibleRuntimes:
        - python3.9
      RetentionPolicy: Delete

  ##########################################################################
  # AppSync
  ##########################################################################

  AppSyncCwlRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com

  AppSyncDynamoDbRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com
      Policies:
        - PolicyName: dynamoDB
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                Resource: !GetAtt EventSourcingTable.Arn

  AppSyncApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Sub "CallAnalytics-${AWS::StackName}"
      AuthenticationType: AMAZON_COGNITO_USER_POOLS
      UserPoolConfig:
        AppIdClientRegex: !Ref UserPoolClient
        AwsRegion: !Ref AWS::Region
        UserPoolId: !Ref UserPool
        # XXX change to DENY and explicitly add access (e.g. Supervisors, Agent)
        DefaultAction: ALLOW
      AdditionalAuthenticationProviders:
        - AuthenticationType: AWS_IAM
      LogConfig:
        CloudWatchLogsRoleArn: !GetAtt AppSyncCwlRole.Arn
        ExcludeVerboseContent: FALSE
        FieldLogLevel: ALL
      # Commenting out Xray as it causes issues with the ServiceLinked role on first deployment
      # similar to: https://github.com/aws/aws-cdk/issues/16598
      # XrayEnabled: true

  AppSyncSchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DefinitionS3Location: ../source/appsync/schema.graphql

  AppSyncDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      Name: CallEventSourcing
      Description: Call Analytics Event Sourcing DynamoDB Table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDbRole.Arn
      DynamoDBConfig:
        TableName: !Ref EventSourcingTable
        AwsRegion: !Ref AWS::Region

  GetCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: getCall
      RequestMappingTemplateS3Location: ../source/appsync/getCall.request.vtl
      ResponseMappingTemplate: $util.toJson($context.result)

  CreateCallAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: createCall
      # This VTL uses a local sub so it needs to be kept here
      RequestMappingTemplate: !Sub |-
        #set( $shardsInDay = 6 )
        #set( $shardDivider = 24 / $shardsInDay )
        #set( $Integer = 0 )
        #set( $now = $util.time.nowISO8601() )

        #set( $date = $now.substring(0, 10) )
        #set( $hourString = $now.substring(11, 13) )
        #set( $hour = $Integer.parseInt($hourString) )

        #set( $hourShard = $hour / $shardDivider )
        #set( $shardPad = $date.format("%02d", $hourShard) )

        #set( $PK = "c#${!ctx.args.input.CallId}" )

        #set( $listPk = "cls#${!date}#s#${!shardPad}" )
        #set( $listSk = "ts#${!now}#id#${!ctx.args.input.CallId}" )

        $util.qr($ctx.args.input.put("CreatedAt", $now))
        $util.qr($ctx.args.input.put("UpdatedAt", $now))
        $util.qr($ctx.args.input.put("Status", "STARTED"))

        {
          "version" : "2018-05-29",
          "operation" : "TransactWriteItems",
          "transactItems": [
            {
              "table": "${EventSourcingTable}",
              "operation": "PutItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($PK),
                "SK": $util.dynamodb.toDynamoDBJson($PK),
              },
              "attributeValues": $util.dynamodb.toMapValuesJson($ctx.args.input),
              "condition": {
                "expression": "attribute_not_exists(#PK)",
                "expressionNames": {
                  "#PK": "PK",
                },
              },
            },
            {
              "table": "${EventSourcingTable}",
              "operation": "PutItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($listPk),
                "SK": $util.dynamodb.toDynamoDBJson($listSk),
              },
              "attributeValues": {
                "CallId": $util.dynamodb.toDynamoDBJson($ctx.args.input.CallId),
                "CreatedAt": $util.dynamodb.toDynamoDBJson($ctx.args.input.CreatedAt),
                "UpdatedAt": $util.dynamodb.toDynamoDBJson($ctx.args.input.UpdatedAt),
              },
            },
          ],
        }
      ResponseMappingTemplateS3Location: ../source/appsync/createCall.response.vtl

  UpdateCallStatusAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updateCallStatus
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  UpdateRecordingUrlAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updateRecordingUrl
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  UpdateCallAggregationAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: updateCallAggregation
      RequestMappingTemplateS3Location: ../source/appsync/updateCall.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  AddTranscriptSegmentAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Mutation
      FieldName: addTranscriptSegment
      RequestMappingTemplateS3Location: ../source/appsync/addTranscriptSegment.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/dDbPutCondition.response.vtl

  ListCallsDateHourAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: listCallsDateHour
      RequestMappingTemplateS3Location: ../source/appsync/listCallsDateHour.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/listCalls.response.vtl

  ListCallsDateShardAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: listCallsDateShard
      RequestMappingTemplateS3Location: ../source/appsync/listCallsDateShard.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/listCalls.response.vtl

  ListCallsAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: listCalls
      RequestMappingTemplateS3Location: ../source/appsync/listCalls.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/listCalls.response.vtl

  GetTranscriptSegmentsAppSyncResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      DataSourceName: !GetAtt AppSyncDataSource.Name
      TypeName: Query
      FieldName: getTranscriptSegments
      RequestMappingTemplateS3Location: ../source/appsync/getTranscriptSegments.request.vtl
      ResponseMappingTemplateS3Location: ../source/appsync/getTranscriptSegments.response.vtl

  ##########################################################################
  # Cognito
  # Sample Cognito resources
  ##########################################################################
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: !If
          - ShouldAllowSignUpEmailDomain
          - false
          - true
        InviteMessageTemplate:
          EmailSubject: Welcome to Live Call Analytics!
          EmailMessage: !Sub |-
            <p>Hello {username},
            <p>Welcome to Live Call Analytics! Your temporary password is:
            <p>     {####}
            <p>
            <p>When the CloudFormation stack is COMPLETE, use the link below to log in to
             the Live Call Analytics web interface and set your permanent password.
            <p>     https://${WebAppCloudFrontDistribution.DomainName}/
            <p>
            <p>Good luck!
            <p>Live Call Analytics (amazon.com/live-call-analytics)
      AutoVerifiedAttributes:
        - email
      EmailConfiguration:
        EmailSendingAccount: COGNITO_DEFAULT
      EmailVerificationMessage: >-
        Please verify your email to complete account registration. Confirmation Code {####}.
      EmailVerificationSubject: >-
        Account Verification
      LambdaConfig: !If
        - ShouldAllowSignUpEmailDomain
        - PreAuthentication: !GetAtt CognitoUserPoolEmailDomainVerifyFunction.Arn
          PreSignUp: !GetAtt CognitoUserPoolEmailDomainVerifyFunction.Arn
        - !Ref AWS::NoValue
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: false
          Required: true
      UserPoolName: !Sub "${AWS::StackName}-UserPool"
      UsernameAttributes:
        - email

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      AccessTokenValidity: 1
      ClientName: !Sub "${AWS::StackName}-Client"
      EnableTokenRevocation: true
      ExplicitAuthFlows:
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      GenerateSecret: false
      IdTokenValidity: 1
      PreventUserExistenceErrors: ENABLED
      ReadAttributes:
        - email
        - email_verified
        - preferred_username
      RefreshTokenValidity: 30
      SupportedIdentityProviders:
        - COGNITO
      UserPoolId: !Ref UserPool

  IdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      IdentityPoolName: !Sub "${AWS::StackName}-IdentityPool"
      AllowUnauthenticatedIdentities: false
      CognitoIdentityProviders:
        - ClientId: !Ref UserPoolClient
          ProviderName: !GetAtt UserPool.ProviderName

  CognitoIdentityPoolSetRole:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId: !Ref IdentityPool
      Roles:
        authenticated: !GetAtt CognitoAuthorizedRole.Arn

  CognitoAuthorizedRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Federated: cognito-identity.amazonaws.com
            Action:
              - sts:AssumeRoleWithWebIdentity
            Condition:
              StringEquals:
                "cognito-identity.amazonaws.com:aud": !Ref IdentityPool
              "ForAnyValue:StringLike":
                "cognito-identity.amazonaws.com:amr": authenticated
      Policies:
        - PolicyName: accessS3RecordingsPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "s3:GetObject"
                Resource:
                  - !Sub
                    - "arn:aws:s3:::${bucket}"
                    - bucket: !If
                        - ShouldCreateRecordingBucket
                        - !Ref RecordingsBucket
                        - !Ref S3BucketName
                  - !Sub
                    - "arn:aws:s3:::${bucket}/*"
                    - bucket: !If
                        - ShouldCreateRecordingBucket
                        - !Ref RecordingsBucket
                        - !Ref S3BucketName
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W12
            reason: comprehend, translate, and connect do not support resource-level permissions

  AdminUser:
    Type: AWS::Cognito::UserPoolUser
    Properties:
      DesiredDeliveryMediums:
        - EMAIL
      UserAttributes:
        - Name: email
          Value: !Ref AdminEmail
      Username: !Ref AdminEmail
      UserPoolId: !Ref UserPool

  AdminGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      Description: Administrators
      GroupName: Admin
      Precedence: 0
      UserPoolId: !Ref UserPool

  AdminUserToGroupAttachment:
    Type: AWS::Cognito::UserPoolUserToGroupAttachment
    Properties:
      GroupName: !Ref AdminGroup
      Username: !Ref AdminUser
      UserPoolId: !Ref UserPool

  CognitoUserPoolEmailDomainVerifyFunction:
    Type: AWS::Serverless::Function
    Condition: ShouldAllowSignUpEmailDomain
    Properties:
      Handler: index.handler
      Runtime: nodejs14.x
      Timeout: 3
      Environment:
        Variables:
          ALLOWED_SIGNUP_EMAIL_DOMAIN: !Ref AllowedSignUpEmailDomain
      InlineCode: |
        exports.handler = async (event, context) => {
          console.log(event);
          const { email } = event.request?.userAttributes;
          if (!email || !email.includes('@')) {
            throw Error('Username does not exists or invalid email address');
          }
          const emailDomain = email?.split('@')[1];
          if (!emailDomain || !process.env?.ALLOWED_SIGNUP_EMAIL_DOMAIN) {
            throw new Error('Server error - invalid configuration');
          }
          if (emailDomain !== process.env?.ALLOWED_SIGNUP_EMAIL_DOMAIN) {
            throw new Error('Invalid email address domain');
          }
          return event;
        };
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired

  CognitoUserPoolEmailDomainVerifyPermission:
    Type: AWS::Lambda::Permission
    Condition: ShouldAllowSignUpEmailDomain
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref CognitoUserPoolEmailDomainVerifyFunction
      Principal: cognito-idp.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !GetAtt UserPool.Arn

  ##########################################################################
  # Web Site
  ##########################################################################

  # Custom resource to empty and delete WebApp bucket when stack is deleted

  BucketDeleteLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "s3:DeleteBucket"
                  - "s3:ListBucket"
                  - "s3:ListBucketVersions"
                  - "s3:DeleteObject"
                  - "s3:DeleteObjectVersion"
                Resource:
                  - !Sub "arn:aws:s3:::${WebAppBucket}"
                  - !Sub "arn:aws:s3:::${WebAppBucket}/*"
          PolicyName: deleteBucketS3Policy

  BucketDeleteLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt BucketDeleteLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          def deleteS3Bucket(bucketName):
             print("Deleting S3 Bucket %s" % bucketName)
             bucket = boto3.resource("s3").Bucket(bucketName)
             bucket.object_versions.all().delete()
             bucket.delete()
          def lambda_handler(event, context):
            print(event)
            responseData = {}
            status = cfnresponse.SUCCESS
            if event['RequestType'] == 'Delete':
              try:
                deleteS3Bucket(event['ResourceProperties']['BucketName'])
              except Exception as e:
                print(e)
                responseData["Error"] = f"Exception thrown: {e}"
                status = cfnresponse.FAILED
                responseData['Data'] = "Success"
            cfnresponse.send(event, context, status, responseData)

  RemoveWebAppBucketOnDelete:
    Type: Custom::RemoveWebAppBucketOnDelete
    Properties:
      ServiceToken: !GetAtt BucketDeleteLambda.Arn
      BucketName: !Ref WebAppBucket

  WebAppBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      # XXX figure out access logging
      # LoggingConfiguration:
      #    DestinationBucketName: !Ref RecordingsBucket
      #    LogFilePrefix: logs/
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html

  WebAppBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebAppBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              CanonicalUser: !GetAtt CloudFrontOriginAccessIdentity.S3CanonicalUserId
            Action: s3:GetObject
            Resource: !Sub "${WebAppBucket.Arn}/*"
          - Effect: "Deny"
            Action:
              - "s3:*"
            Principal: "*"
            Resource:
              - !GetAtt WebAppBucket.Arn
              - !Sub "${WebAppBucket.Arn}/*"
            Condition:
              Bool:
                "aws:SecureTransport": false

  CloudFrontOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub "CloudFront OAI for ${WebAppBucket}"

  WebAppCloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Comment: !Sub "Web app cloudfront distribution ${AWS::StackName}"
        CustomErrorResponses:
          # Send errors to index file
          - ErrorCachingMinTTL: 300
            ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCachingMinTTL: 300
            ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          Compress: true
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          TargetOriginId: webapp-s3-bucket
          ViewerProtocolPolicy: redirect-to-https
          DefaultTTL: 600
          MinTTL: 300
          MaxTTL: 900
        DefaultRootObject: index.html
        Enabled: true
        HttpVersion: http2
        IPV6Enabled: true
        # Logging:
        #   Bucket: !GetAtt RecordingsBucket.DomainName
        #   IncludeCookies: false
        #   Prefix: logs/cloudfront/
        Origins:
          - Id: webapp-s3-bucket
            DomainName: !GetAtt WebAppBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity:
                !Sub "origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}"
        PriceClass: !Ref CloudFrontPriceClass
        Restrictions: !If
          - ShouldEnableGeoRestriction
          - GeoRestriction:
              RestrictionType: whitelist
              Locations:
                !Split [',', !Ref CloudFrontAllowedGeos]
          - GeoRestriction:
              RestrictionType: none
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W70
            reason: This is using Cloudfront default TLS, can be changed by customer if needed.
